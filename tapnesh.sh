#!/bin/sh
#
# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html
#
# ARG_OPTIONAL_SINGLE([quality],[q],[Sets quailty for optimized images, can be a value from 1 to 100. (100 means loseless optimization)],[85])
# ARG_OPTIONAL_SINGLE([path],[p],[Path to directory for optimization],[.])
# ARG_OPTIONAL_BOOLEAN([recursive],[R],[Do recursive],[off])
# ARG_OPTIONAL_BOOLEAN([verbose],[v],[Be verbose],[off])
# ARG_OPTIONAL_BOOLEAN([keep],[k],[Keep old files],[off])
# ARG_HELP([Tapnesh is wrapper for image optimizers, It simply lets you optimize images in directory(ies) or single images in parallel])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.5.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

# When called, the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to )
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

# Function that evaluates whether a value passed to it
# begins by a character that is a short option of an argument
# the script knows about
begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='qpRvkh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_quality="85"
_arg_path="."
_arg_recursive=off
_arg_verbose=off
_arg_keep=off

# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help ()
{
	printf "%s\n" "Tapnesh is wrapper for image optimizers, It simply lets you optimize images in directory(ies) or single images in parallel"
	printf 'Usage: %s [-q|--quality <arg>] [-p|--path <arg>] [-R|--(no-)recursive] [-v|--(no-)verbose] [-k|--(no-)keep] [-h|--help]\n' "$0"
	printf "\t%s\n" "-q,--quality: Sets quailty for optimized images, can be a value from 1 to 100. (100 means loseless optimization) (default: '"85"')"
	printf "\t%s\n" "-p,--path: Path to directory for optimization (default: '"."')"
	printf "\t%s\n" "-R,--recursive,--no-recursive: Do recursive (off by default)"
	printf "\t%s\n" "-v,--verbose,--no-verbose: Be verbose (off by default)"
	printf "\t%s\n" "-k,--keep,--no-keep: Keep old files (off by default)"
	printf "\t%s\n" "-h,--help: Prints help"
}

# The parsing of the command-line
parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			# We support whitespace as a delimiter between option argument and its value.
			# Therefore, we expect the --quality or -q value.
			# so we watch for --quality and -q.
			# Since we know that we got the long or short option,
			# we just reach out for the next argument to get the value.
			-q|--quality)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_quality="$2"
				shift
				;;
			# We support the = as a delimiter between option argument and its value.
			# Therefore, we expect --quality=value, so we watch for --quality=*
			# For whatever we get, we strip '--quality=' using the ${var##--quality} notation
			# to get the argument value
			--quality=*)
				_arg_quality="${_key##--quality=}"
				;;
			# We support getopts-style short arguments clustering,
			# so as -q accepts value, we allow it to be appended to it, so we watch for -q*
			# and we strip the leading -q from the argument string using the ${var##-q} notation.
			-q*)
				_arg_quality="${_key##-q}"
				;;
			# See the comment of option --quality to see what's going on here
			-p|--path)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_path="$2"
				shift
				;;
			# See the comment of option --quality= to see what's going on here
			--path=*)
				_arg_path="${_key##--path=}"
				;;
			# See the comment of option -q to see what's going on here
			-p*)
				_arg_path="${_key##-p}"
				;;
			# The recursive argurment doesn't accept a value,
			# we expect the --recursive or -R, so we watch for them.
			-R|--no-recursive|--recursive)
				_arg_recursive="on"
				test "${1:0:5}" = "--no-" && _arg_recursive="off"
				;;
			# We support getopts-style short arguments clustering,
			# so as -R doesn't accepts value, other short options may appended to it, so we watch for -R*.
			# After strip the leading -R from the argument,
			# we have to make sure that the first character coresponds to a short option.
			-R*)
				_arg_recursive="on"
				_next="${_key##-R}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-R" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option --recursive to see what's going on here
			-v|--no-verbose|--verbose)
				_arg_verbose="on"
				test "${1:0:5}" = "--no-" && _arg_verbose="off"
				;;
			# See the comment of option -R to see what's going on here
			-v*)
				_arg_verbose="on"
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option --recursive to see what's going on here
			-k|--no-keep|--keep)
				_arg_keep="on"
				test "${1:0:5}" = "--no-" && _arg_keep="off"
				;;
			# See the comment of option -R to see what's going on here
			-k*)
				_arg_keep="on"
				_next="${_key##-k}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-k" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option --recursive to see what's going on here
			-h|--help)
				print_help
				exit 0
				;;
			# See the comment of option -R to see what's going on here
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}


validate_quality(){
	QUALITY=$1
	MIN_QUALITY_VALUE=1
	MAX_QUALITY_VALUE=100

	if [ $QUALITY -lt $MIN_QUALITY_VALUE ]; then
		echo "[!] Minimum value for quality is $MIN_QUALITY_VALUE";
		echo "[!] Exiting ..."
		exit -1
	elif [ $QUALITY -gt $MAX_QUALITY_VALUE ]; then
		echo "[!] Maximum value for quality is $MAX_QUALITY_VALUE";
		echo "[!] Exiting ..."
		exit -1
	fi

}


# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"


#Arguments validation
validate_quality $_arg_quality

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash
log (){
	if [[ $_arg_verbose == "on" ]]; then
		echo $1
	fi
}

PREFIX="tapnesh_"

if [[ -f $_arg_path ]]; then #Check if path is a file
	IMG="$_arg_path"
	FILE_FULL_PATH=$(readlink -f "$_arg_path")
	log "[L] Processing $FILE_FULL_PATH"
	#Find file extension base on magic number, not name since sometimes images get saved with wrong extensions
	MIMETYPE=$(file "$IMG" --mime-type -b)
	if [[ $MIMETYPE == "image/jpeg" ]]; then
		log "[L] jpeg file"
		OPTIONS="--strip-all -m$_arg_quality "
		if [[ $_arg_keep == "on" ]]; then #Create e forced backup if they wanna keep old files
			log "[L] backing up ..."
			/bin/cp -f "$IMG" "$(dirname $IMG)/$PREFIX$(basename $IMG)"
		fi
		sh -c "/usr/bin/jpegoptim $OPTIONS $IMG"
	elif [[ $MIMETYPE == "image/png" ]]; then
		log "[L] Png file ..."
		OPTIONS="--strip --speed 1 -f --quality $_arg_quality-$_arg_quality"
		if [[ $_arg_keep == "on" ]]; then
			log "[L] Backing up..."
			OPTIONS="$OPTIONS --output '$(dirname "$IMG")/$PREFIX$(basename "$IMG")' "
		else
			OPTIONS="$OPTIONS --output '$(dirname "$IMG")/$(basename "$IMG")' "
		fi
		log "[L] Compressing"
		sh -c "/usr/bin/pngquant $OPTIONS '$IMG'"
	else
		echo "[E] Invalid image type !"
	fi

	log "[L] Done image"
elif [[ -d $_arg_path ]]; then
	#User wants to optimize a directory
	#Check if he/she wants recursive option

	TIME_BEFORE=$(date +%s.%N)
	SIZE_BEFORE=$(du $_arg_path -s | cut -f1)
	FIND_OPTIONS=" -iregex '.*\.\(jpg\|png\|jpeg\)$' "

	if [[ $_arg_recursive == "off" ]]; then
		FIND_OPTIONS="-maxdepth 1 $FIND_OPTIONS "
	fi
	FIND_CMD="find "$_arg_path" $FIND_OPTIONS"

	PARALLEL_OPTIONS=" --no-notice --jobs 0 "

	TAPNESH_OPTIONS="-q $_arg_quality"
	if [[ $_arg_keep == "on" ]]; then
		TAPNESH_OPTIONS="--keep $TAPNESH_OPTIONS"
	fi

	if [[ $_arg_verbose == "on" ]]; then
		TAPNESH_OPTIONS="--verbose $TAPNESH_OPTIONS"
	fi

	echo "[*] Finding images and processing in parallel at same time..."
	sh -c "$FIND_CMD | /usr/bin/parallel $PARALLEL_OPTIONS /usr/local/bin/tapnesh $TAPNESH_OPTIONS -p {}"
	log "[L] Compressing directory has been finished!"
	TIME_AFTER=$(date +%s.%N)

	TOTAL_TIME=$(awk -v item=$TIME_AFTER -v total=$TIME_BEFORE 'BEGIN { printf "%.3f\n", item - total }')

	SIZE_AFTER=$(du $_arg_path -s | cut -f1)
	OPT_PERCENT=$(awk -v item=$SIZE_AFTER -v total=$SIZE_BEFORE 'BEGIN { printf "%.3f\n", 100 * item / total }')


	echo "[*] Processing time: ${TOTAL_TIME}s"
	if [[ $_arg_keep == "off" ]]; then
		echo "[*] Size Before:${SIZE_BEFORE}kb, After:${SIZE_AFTER}kb  ($OPT_PERCENT% Size decreasing)"
	fi
fi

# ] <-- needed because of Argbash
